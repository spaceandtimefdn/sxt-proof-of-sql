use crate::intermediate_ast;
use crate::select_statement;
use crate::identifier;
use lalrpop_util::ParseError::User;

grammar;

////////////////////////////////////////////////////////////////////////////////////////////////
// We only need to support SELECT statements on this SQL parser.
//
// Besides, the grammar here is strictly following Postgres grammar rules defined here: 
// https://www.postgresql.org/docs/current/sql-syntax-lexical.html
////////////////////////////////////////////////////////////////////////////////////////////////

pub SelectStatement: select_statement::SelectStatement = {
    <expr: SelectCore> <order_by: ("order" "by" <OrderByList>)?> <slice: SliceClause?> => 
        select_statement::SelectStatement {
            expr,
            order_by: order_by.unwrap_or(vec![]),
            slice
        },
};

SelectCore: Box<intermediate_ast::SetExpression> = {
    "select" <columns: ResultColumnList> <from: FromClause> <where_expr: WhereClause?> =>
        Box::new(intermediate_ast::SetExpression::Query{ columns, from, where_expr }),
};


////////////////////////////////////////////////////////////////////////////////////////////////
// Order By
////////////////////////////////////////////////////////////////////////////////////////////////

OrderByList: Vec<intermediate_ast::OrderBy> = {
    <order_by: OrderByCore> => vec![<>],

    <order_by_list: OrderByList> "," <order_by: OrderByCore> => intermediate_ast::append(order_by_list, order_by),    
};

OrderByCore: intermediate_ast::OrderBy = {
    <col_id: Identifier> "asc"? => intermediate_ast::OrderBy {
            expr: col_id, direction: intermediate_ast::OrderByDirection::Asc,
    },

    <col_id: Identifier> "desc" => intermediate_ast::OrderBy {
            expr: col_id, direction: intermediate_ast::OrderByDirection::Desc,
    },
};

////////////////////////////////////////////////////////////////////////////////////////////////
// Limit Clause
////////////////////////////////////////////////////////////////////////////////////////////////

SliceClause: intermediate_ast::Slice = {
    <limit: LimitClause> => intermediate_ast::Slice {
        number_rows: limit,
        offset_value: 0,
    },
    <offset: OffsetClause> => intermediate_ast::Slice {
        number_rows: u64::MAX,
        offset_value: offset,
    },
    <offset: OffsetClause> <number_rows: LimitClause> => intermediate_ast::Slice {
        number_rows: number_rows,
        offset_value: offset,
    },
    <number_rows: LimitClause> <offset: OffsetClause> => intermediate_ast::Slice {
        number_rows: number_rows,
        offset_value: offset,
    },
};

LimitClause: u64 = {
    "LIMIT" "ALL" => u64::MAX,
    "LIMIT" <number_rows: UnsignedNumericLiteral> => number_rows,
};

OffsetClause: i64 = {
    "OFFSET" <offset: SignedNumericLiteral> => offset,
};

////////////////////////////////////////////////////////////////////////////////////////////////
// Result Columns
////////////////////////////////////////////////////////////////////////////////////////////////

ResultColumnList: Vec<Box<intermediate_ast::ResultColumn>> = {
    ResultColumn => vec![<>],

    <columns: ResultColumnList> "," <column: ResultColumn> => intermediate_ast::append(columns, column),
};

ResultColumn: Box<intermediate_ast::ResultColumn> = {
    "*" => Box::new(intermediate_ast::ResultColumn::All),

    <expr: QualifiedColumnIdentifier> => Box::new(intermediate_ast::ResultColumn::Expr { expr: expr.clone(), output_name: expr }),

    <expr: QualifiedColumnIdentifier> "as"? <output_name: Identifier>  =>
            Box::new(intermediate_ast::ResultColumn::Expr { expr, output_name: output_name }),
};

// Note: we are adding a new `QualifiedColumnIdentifierParen` rule
// solely for the purpose of overcoming LALRPOP restrictions.
// For instance, see this thread:
// [here](https://gitter.im/lalrpop/Lobby?at=6368164d9ee3ec22b4fa69cb)
QualifiedColumnIdentifierParen: identifier::Identifier = "(" <QualifiedColumnIdentifier> ")";
QualifiedColumnIdentifier: identifier::Identifier = {
    #[precedence(level="0")]
    QualifiedColumnIdentifierParen,

    #[precedence(level="1")]
    Identifier,
};

////////////////////////////////////////////////////////////////////////////////////////////////
// FromClause
////////////////////////////////////////////////////////////////////////////////////////////////

FromClause: Vec<Box<intermediate_ast::TableExpression>> = {
    "from" <table_ref: TableExpression> => vec![table_ref],
};

TableExpression: Box<intermediate_ast::TableExpression> = {
    <table: QualifiedTableIdentifier> => table,
};

QualifiedTableIdentifierParen: Box<intermediate_ast::TableExpression> = "(" <QualifiedTableIdentifier> ")";
QualifiedTableIdentifier: Box<intermediate_ast::TableExpression> = {
    #[precedence(level="0")]
    QualifiedTableIdentifierParen,

    #[precedence(level="1")]
    <schema: (<Identifier> ".")?> <table: Identifier> =>
        Box::new(intermediate_ast::TableExpression::Named { table, schema }),
};

////////////////////////////////////////////////////////////////////////////////////////////////
// WhereClause
////////////////////////////////////////////////////////////////////////////////////////////////

WhereClause: Box<intermediate_ast::Expression> = {
    "where" <expr: Expression> => expr,
};

////////////////////////////////////////////////////////////////////////////////////////////////
// Expressions
////////////////////////////////////////////////////////////////////////////////////////////////
ExprParen: Box<intermediate_ast::Expression> = "(" <Expression> ")";
Expression: Box<intermediate_ast::Expression> = {
    #[precedence(level="0")]
    ExprParen,

    #[precedence(level="1")]
    ComparativeExpression,

    #[precedence(level="2")] #[assoc(side="right")]
    "not" <expr: Expression> => Box::new(intermediate_ast::Expression::Not { expr }),

    #[precedence(level="3")] #[assoc(side="left")]
    <left: Expression> "and" <right: Expression> =>
        Box::new(intermediate_ast::Expression::And { left, right }),

    #[precedence(level="4")] #[assoc(side="left")]
    <left: Expression> "or" <right: Expression> =>
        Box::new(intermediate_ast::Expression::Or { left, right }),
};

ComparativeExpression: Box<intermediate_ast::Expression> = {
    <left: QualifiedColumnIdentifier> "=" <right: LiteralValue> =>
        Box::new(intermediate_ast::Expression::Equal { left, right }),

    <left: LiteralValue> "=" <right: QualifiedColumnIdentifier> =>
        Box::new(intermediate_ast::Expression::Equal { left: right, right: left }),

    <left: QualifiedColumnIdentifier> "!=" <right: LiteralValue> =>
        Box::new(intermediate_ast::Expression::Not {
            expr: Box::new(intermediate_ast::Expression::Equal { left, right })
        }),

    <left: LiteralValue> "!=" <right: QualifiedColumnIdentifier> =>
        Box::new(intermediate_ast::Expression::Not {
            expr: Box::new(intermediate_ast::Expression::Equal { left: right, right: left })
        }),
};

UnaryNumericLiteralParen: i64 = "(" <UnaryNumericLiteral> ")";
UnaryNumericLiteral: i64 = {
    #[precedence(level="0")]
    UnaryNumericLiteralParen,

    #[precedence(level="1")]
    SignedNumericLiteral,

    #[precedence(level="2")] #[assoc(side="right")]
    "+" <expr: UnaryNumericLiteral> => expr,
    "-" <expr: UnaryNumericLiteral> =>? expr.checked_neg().ok_or(User {error: "Integer overflow"}),
};

StringLiteralParen: String = "(" <StringLiteral> ")";
pub StringLiteral: String = {
    #[precedence(level="0")]
    StringLiteralParen,

    STRING_LITERAL => <>[1..<>.len() - 1].to_string(),
};

LiteralValue: Box<intermediate_ast::Literal> = {
    <value: StringLiteral> => Box::new(intermediate_ast::Literal::VarChar(<>)),

    <value: UnaryNumericLiteral> => Box::new(intermediate_ast::Literal::BigInt(<>)),
};

////////////////////////////////////////////////////////////////////////////////////////////////
// Tokens
////////////////////////////////////////////////////////////////////////////////////////////////

pub(crate) ResourceId: (identifier::Identifier, identifier::Identifier) = {
    <schema: Identifier> "." <object_name: Identifier> => (schema, object_name)
};

pub(crate) Identifier: identifier::Identifier = ID =>? if <>.len() <= 64 {
    Ok(identifier::Identifier::new(<>))
} else {
    Err(User {error: "Identifier is too long, must be 64 bytes or less (note this may be <64 characters in UTF8)"})
};

SignedNumericLiteral: i64 = {
    NUMERIC_LIT =>? <>.parse::<i64>().map_err(|_| User {error: "Integer out of range"}),
};

UnsignedNumericLiteral: u64 = {
    NUMERIC_LIT =>? <>.parse::<u64>().map_err(|_| User {error: "Integer out of range"}),
};

////////////////////////////////////////////////////////////////////////////////////////////////
// Lexer specification, with the primary purpose of making language keywords case insensitive //
////////////////////////////////////////////////////////////////////////////////////////////////

match {
    r"(?i)all" => "ALL",
    r"(?i)asc" => "asc",
    r"(?i)desc" => "desc",
    r"(?i)as" => "as",
    r"(?i)and" => "and",
    r"(?i)from" => "from",
    r"(?i)not" => "not",
    r"(?i)or" => "or",
    r"(?i)select" => "select",
    r"(?i)where" => "where",
    r"(?i)order" => "order",
    r"(?i)by" => "by",
    r"(?i)limit" => "LIMIT",
    r"(?i)offset" => "OFFSET",

    "," => ",",
    "." => ".",
    "(" => "(",
    ")" => ")",
    "+" => "+",
    "-" => "-",
    "*" => "*",
    "=" => "=",
    r"(!=|<>)" => "!=",
} else {
    r"[A-Za-z_][A-Za-z0-9_]*" => ID,
    r"[+-]?[0-9]+([0-9]*)" => NUMERIC_LIT,
    r"'(?s)[^']*'" => STRING_LITERAL,
}
