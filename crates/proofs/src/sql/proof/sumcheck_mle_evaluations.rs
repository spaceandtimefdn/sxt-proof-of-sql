use super::{Indexes, SumcheckRandomScalars};
use crate::base::{
    polynomial::{
        compute_truncated_lagrange_basis_inner_product, compute_truncated_lagrange_basis_sum,
    },
    scalar::ArkScalar,
};

/// Evaluations for different MLEs at the random point chosen for sumcheck
#[derive(Default)]
pub struct SumcheckMleEvaluations<'a> {
    /// The length of the input table for a basic filter. When we support more complex queries, this may need to split.
    pub table_length: usize,
    /// The number of sumcheck variables.
    pub num_sumcheck_variables: usize,
    /// The evaluation (at the random point generated by sumcheck) of an MLE {x_i} where
    ///     x_i = 1, if i < table_length;
    ///         = 0, otherwise
    pub one_evaluation: ArkScalar,

    /// The evaluation (at the random point generated by sumcheck) of the MLE that is 1 at the result indexes and 0 elsewhere.
    /// This is only computed if the result indexes are dense, and is None otherwise.
    pub result_indexes_evaluation: Option<ArkScalar>,

    /// The evaluation (at the random point generated by sumcheck) of the MLE formed from entrywise random scalars.
    ///
    /// This is used within sumcheck to establish that a given expression
    /// is zero across all entries.
    pub random_evaluation: ArkScalar,
    /// The evaluations (at the random point generated by sumcheck) of the mles that are evaluated by the inner product argument. These are batched together and checked by a single IPA.
    pub pre_result_evaluations: &'a [ArkScalar],
    /// The evaluations (at the random point generated by sumcheck) of the final result table columns.
    pub result_evaluations: &'a [ArkScalar],
}

impl<'a> SumcheckMleEvaluations<'a> {
    #[tracing::instrument(
        name = "proofs.sql.proof.sumcheck_mle_evaluations.new",
        level = "info",
        skip_all
    )]
    /// Constructs the evaluations for the sumcheck MLEs.
    ///
    /// # Inputs
    /// - `evaluation_point` - the point, outputted by sumcheck, at which to evaluate the MLEs
    /// - `sumcheck_random_scalars` - the random scalars used to batch the evaluations that are proven via IPA
    /// - `pre_result_evaluations` - the evaluations of the MLEs that are proven via IPA
    /// - `result_evaluations` - the evaluations of the final result table columns
    /// - `result_indexes` - the indexes of the entries in the result columns. This can be sparse or dense
    pub fn new(
        table_length: usize,
        evaluation_point: &[ArkScalar],
        sumcheck_random_scalars: &SumcheckRandomScalars<ArkScalar>,
        pre_result_evaluations: &'a [ArkScalar],
        result_evaluations: &'a [ArkScalar],
        result_indexes: &Indexes,
    ) -> Self {
        assert_eq!(
            evaluation_point.len(),
            sumcheck_random_scalars.entrywise_point.len()
        );
        assert_eq!(table_length, sumcheck_random_scalars.table_length);
        let random_evaluation = compute_truncated_lagrange_basis_inner_product(
            table_length,
            evaluation_point,
            sumcheck_random_scalars.entrywise_point,
        );
        let one_evaluation = compute_truncated_lagrange_basis_sum(table_length, evaluation_point);

        let result_indexes_evaluation = result_indexes.evaluate_at_point(evaluation_point);

        Self {
            table_length,
            num_sumcheck_variables: evaluation_point.len(),
            one_evaluation,
            random_evaluation,
            pre_result_evaluations,
            result_evaluations,
            result_indexes_evaluation,
        }
    }
}
