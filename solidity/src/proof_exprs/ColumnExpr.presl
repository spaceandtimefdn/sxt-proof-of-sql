// SPDX-License-Identifier: UNLICENSED
// This is licensed under the Cryptographic Open Software License 1.0
pragma solidity ^0.8.26;

import "../base/Constants.sol";
import "../base/Errors.sol";

/// @title ColumnExpr
/// @dev Library for handling column expressions
library ColumnExpr {
    /// @notice Evaluates a column expression
    /// @custom:as-yul-wrapper
    /// #### Wrapped Yul Function
    /// ##### Signature
    /// ```yul
    /// column_expr_evaluate(expr_ptr, accessor) -> expr_ptr_out, eval
    /// ```
    /// ##### Parameters
    /// * `expr_ptr` - calldata pointer to the column expression
    /// * `accessor` - memory pointer to the collection of evals
    /// ##### Return Values
    /// * `expr_ptr_out` - pointer to the remaining expression after consuming the column expression
    /// * `eval` - the evaluation result from looking up the column value
    /// ##### Proof Plan Encoding
    /// The column expression is encoded as follows:
    /// 1. The column index (as a uint64)
    /// @dev Reads a uint64 column index from the expression and looks up its evaluation
    /// @param __expr The input column expression
    /// @param __accessor The collection of evals
    /// @return __exprOut The remaining expression after consuming the column index
    /// @return __eval The evaluation result for the column
    function __columnExprEvaluate( // solhint-disable-line gas-calldata-parameters
    bytes calldata __expr, uint256[] memory __accessor)
        external
        pure
        returns (bytes calldata __exprOut, uint256 __eval)
    {
        assembly {
            // import get_array_element from ../base/Array.presl

            function column_expr_evaluate(expr_ptr, accessor) -> expr_ptr_out, eval {
                let column_num := shr(UINT64_PADDING_BITS, calldataload(expr_ptr))
                expr_ptr := add(expr_ptr, UINT64_SIZE)

                eval := get_array_element(accessor, column_num)

                expr_ptr_out := expr_ptr
            }
            let __exprOutOffset
            __exprOutOffset, __eval := column_expr_evaluate(__expr.offset, __accessor)
            __exprOut.offset := __exprOutOffset
            // slither-disable-next-line write-after-write
            __exprOut.length := sub(__expr.length, sub(__exprOutOffset, __expr.offset))
        }
    }
}
