// SPDX-License-Identifier: UNLICENSED
// This is licensed under the Cryptographic Open Software License 1.0
pragma solidity ^0.8.26;

import "../base/Constants.sol";
import "../base/Errors.sol";
import {VerificationBuilder} from "../builder/VerificationBuilder.presl";

/// @title ProofExpr
/// @dev Library for handling proof expressions which can be either column or literal expressions
library ProofExpr {
    enum ExprVariant {
        Column,
        Literal,
        Equals,
        Add,
        Subtract,
        Multiply,
        And,
        Or,
        Not,
        Cast,
        Inequality,
        Placeholder,
        ScalingCast
    }

    /// @notice Evaluates a proof expression
    /// @custom:as-yul-wrapper
    /// #### Wrapped Yul Function
    /// ##### Signature
    /// ```yul
    /// proof_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor) -> expr_ptr_out, eval
    /// ```
    /// ##### Parameters
    /// * `expr_ptr` - calldata pointer to the proof expression
    /// * `builder_ptr` - memory pointer to the verification builder
    /// * `chi_eval` - the chi value for this expression. This is the evaluation of a column of ones of
    /// * `accessor` - memory pointer to the collection of evals
    ///   length equal to the columns in the expression
    /// ##### Return Values
    /// * `expr_ptr_out` - pointer to the remaining expression after consuming the proof expression
    /// * `eval` - the evaluation of the result of this expression. Critically, this resulting evaluation must be guarenteed to be
    ///   the correct evaluation of a column with the same length as the columns in the expression. Every column has implicit infinite length
    ///   but is padded with zeros. This is guarenteed to match the length of the chi column, and varients must be designed to handle this.
    /// ##### Proof Plan Encoding
    /// The proof expression is encoded as follows:
    /// 1. The expression variant (as a uint32)
    /// 2. The expression data of the variant itself
    /// @dev Reads the variant and delegates to the appropriate expression evaluator
    /// @param __expr The input proof expression
    /// @param __builder The verification builder containing column evaluations
    /// @param __chiEval The chi value for literal evaluation
    /// @param __accessor The collection of evals
    /// @return __exprOut The remaining expression after consuming the proof expression
    /// @return __builderOut The verification builder result
    /// @return __eval The evaluation result
    function __proofExprEvaluate( // solhint-disable-line gas-calldata-parameters
    bytes calldata __expr, VerificationBuilder.Builder memory __builder, uint256 __chiEval, uint256[] memory __accessor)
        external
        pure
        returns (bytes calldata __exprOut, VerificationBuilder.Builder memory __builderOut, uint256 __eval)
    {
        assembly {
            // import err from ../base/Errors.sol
            // import case_const from ../base/SwitchUtil.presl
            // import column_expr_evaluate from ColumnExpr.presl
            // import literal_expr_evaluate from LiteralExpr.presl
            // import equals_expr_evaluate from EqualsExpr.presl
            // import add_expr_evaluate from AddExpr.presl
            // import subtract_expr_evaluate from SubtractExpr.presl
            // import multiply_expr_evaluate from MultiplyExpr.presl
            // import and_expr_evaluate from AndExpr.presl
            // import or_expr_evaluate from OrExpr.presl
            // import not_expr_evaluate from NotExpr.presl
            // import cast_expr_evaluate from CastExpr.presl
            // import inequality_expr_evaluate from InequalityExpr.presl
            // import placeholder_expr_evaluate from PlaceholderExpr.presl
            // import scaling_cast_expr_evaluate from ScalingCastExpr.presl

            // slither-disable-start cyclomatic-complexity
            function proof_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor) -> expr_ptr_out, eval {
                let proof_expr_variant := shr(UINT32_PADDING_BITS, calldataload(expr_ptr))
                expr_ptr := add(expr_ptr, UINT32_SIZE)

                switch proof_expr_variant
                case 0 {
                    case_const(0, COLUMN_EXPR_VARIANT)
                    expr_ptr_out, eval := column_expr_evaluate(expr_ptr, accessor)
                }
                case 1 {
                    case_const(1, LITERAL_EXPR_VARIANT)
                    expr_ptr_out, eval := literal_expr_evaluate(expr_ptr, chi_eval)
                }
                case 2 {
                    case_const(2, EQUALS_EXPR_VARIANT)
                    expr_ptr_out, eval := equals_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor)
                }
                case 3 {
                    case_const(3, ADD_EXPR_VARIANT)
                    expr_ptr_out, eval := add_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor)
                }
                case 4 {
                    case_const(4, SUBTRACT_EXPR_VARIANT)
                    expr_ptr_out, eval := subtract_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor)
                }
                case 5 {
                    case_const(5, MULTIPLY_EXPR_VARIANT)
                    expr_ptr_out, eval := multiply_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor)
                }
                case 6 {
                    case_const(6, AND_EXPR_VARIANT)
                    expr_ptr_out, eval := and_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor)
                }
                case 7 {
                    case_const(7, OR_EXPR_VARIANT)
                    expr_ptr_out, eval := or_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor)
                }
                case 8 {
                    case_const(8, NOT_EXPR_VARIANT)
                    expr_ptr_out, eval := not_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor)
                }
                case 9 {
                    case_const(9, CAST_EXPR_VARIANT)
                    expr_ptr_out, eval := cast_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor)
                }
                case 10 {
                    case_const(10, INEQUALITY_EXPR_VARIANT)
                    expr_ptr_out, eval := inequality_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor)
                }
                case 11 {
                    case_const(11, PLACEHOLDER_EXPR_VARIANT)
                    expr_ptr_out, eval := placeholder_expr_evaluate(expr_ptr, builder_ptr, chi_eval)
                }
                case 12 {
                    case_const(12, SCALING_CAST_EXPR_VARIANT)
                    expr_ptr_out, eval := scaling_cast_expr_evaluate(expr_ptr, builder_ptr, chi_eval, accessor)
                }
                default { err(ERR_UNSUPPORTED_PROOF_EXPR_VARIANT) }
            }
            // slither-disable-end cyclomatic-complexity
            let __exprOutOffset
            __exprOutOffset, __eval := proof_expr_evaluate(__expr.offset, __builder, __chiEval, __accessor)
            __exprOut.offset := __exprOutOffset
            // slither-disable-next-line write-after-write
            __exprOut.length := sub(__expr.length, sub(__exprOutOffset, __expr.offset))
        }
        __builderOut = __builder;
    }
}
