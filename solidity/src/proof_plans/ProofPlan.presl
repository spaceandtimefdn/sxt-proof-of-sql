// SPDX-License-Identifier: UNLICENSED
// This is licensed under the Cryptographic Open Software License 1.0
pragma solidity ^0.8.28;

import "../base/Constants.sol";
import "../base/Errors.sol";
import {VerificationBuilder} from "../builder/VerificationBuilder.presl";

/// @title ProofPlan
/// @dev Library for handling proof plans
library ProofPlan {
    enum PlanVariant {
        Filter,
        Empty,
        Table,
        Projection,
        Slice,
        GroupBy,
        Union,
        SortMergeJoin,
        GeneralizedFilter
    }

    /// @notice Evaluates a proof plan
    /// @custom:as-yul-wrapper
    /// #### Wrapped Yul Function
    /// ##### Signature
    /// ```yul
    /// proof_plan_evaluate(plan_ptr, builder_ptr) -> plan_ptr_out, evaluations_ptr
    /// ```
    /// ##### Parameters
    /// * `plan_ptr` - calldata pointer to the proof plan
    /// * `builder_ptr` - memory pointer to the verification builder
    /// ##### Return Values
    /// * `plan_ptr_out` - pointer to the remaining plan after consuming the proof plan
    /// * `evaluations_ptr` - pointer to the evaluations
    /// * `output_length` - the length of the column of ones
    /// * `output_chi_eval` - pointer to the evaluation of a column of 1s with same length output
    /// @dev Evaluates a proof plan by dispatching to the appropriate sub-plan evaluator
    /// @param __plan The proof plan data
    /// @param __builder The verification builder
    /// @return __planOut The remaining plan after processing
    /// @return __builderOut The updated verification builder
    /// @return __evaluations The evaluations pointer
    /// @return __outputLength The length of the output chi evaluation
    /// @return __outputChiEvaluation The output chi evaluation
    function __proofPlanEvaluate( // solhint-disable-line gas-calldata-parameters
    bytes calldata __plan, VerificationBuilder.Builder memory __builder)
        external
        pure
        returns (
            bytes calldata __planOut,
            VerificationBuilder.Builder memory __builderOut,
            uint256[] memory __evaluations,
            uint256 __outputLength,
            uint256 __outputChiEvaluation
        )
    {
        assembly {
            // import err from ../base/Errors.sol
            // import case_const from ../base/SwitchUtil.presl
            // import empty_exec_evaluate from EmptyExec.presl
            // import filter_exec_evaluate from FilterExec.presl
            // import table_exec_evaluate from TableExec.presl
            // import projection_exec_evaluate from ProjectionExec.presl
            // import slice_exec_evaluate from SliceExec.presl
            // import group_by_exec_evaluate from GroupByExec.presl
            // import union_exec_evaluate from UnionExec.presl
            // import sort_merge_join_evaluate from SortMergeJoinExec.presl
            // import generalized_filter_exec_evaluate from GeneralizedFilterExec.presl

            function proof_plan_evaluate(plan_ptr, builder_ptr) -> plan_ptr_out, evaluations_ptr, output_length, output_chi_eval {
                let proof_plan_variant := shr(UINT32_PADDING_BITS, calldataload(plan_ptr))
                plan_ptr := add(plan_ptr, UINT32_SIZE)

                switch proof_plan_variant
                case 0 {
                    case_const(0, FILTER_EXEC_VARIANT)
                    plan_ptr_out, evaluations_ptr, output_length, output_chi_eval :=
                        filter_exec_evaluate(plan_ptr, builder_ptr)
                }
                case 1 {
                    case_const(1, EMPTY_EXEC_VARIANT)
                    evaluations_ptr, output_length, output_chi_eval := empty_exec_evaluate(builder_ptr)
                    plan_ptr_out := plan_ptr
                }
                case 2 {
                    case_const(2, TABLE_EXEC_VARIANT)
                    plan_ptr_out, evaluations_ptr, output_length, output_chi_eval :=
                        table_exec_evaluate(plan_ptr, builder_ptr)
                }
                case 3 {
                    case_const(3, PROJECTION_EXEC_VARIANT)
                    plan_ptr_out, evaluations_ptr, output_length, output_chi_eval :=
                        projection_exec_evaluate(plan_ptr, builder_ptr)
                }
                case 4 {
                    case_const(4, SLICE_EXEC_VARIANT)
                    plan_ptr_out, evaluations_ptr, output_length, output_chi_eval :=
                        slice_exec_evaluate(plan_ptr, builder_ptr)
                }
                case 5 {
                    case_const(5, GROUP_BY_EXEC_VARIANT)
                    plan_ptr_out, evaluations_ptr, output_length, output_chi_eval :=
                        group_by_exec_evaluate(plan_ptr, builder_ptr)
                }
                case 6 {
                    case_const(6, UNION_EXEC_VARIANT)
                    plan_ptr_out, evaluations_ptr, output_length, output_chi_eval :=
                        union_exec_evaluate(plan_ptr, builder_ptr)
                }
                case 7 {
                    case_const(7, SORT_MERGE_JOIN_EXEC_VARIANT)
                    plan_ptr_out, evaluations_ptr, output_length, output_chi_eval :=
                        sort_merge_join_evaluate(plan_ptr, builder_ptr)
                }
                case 8 {
                    case_const(8, GENERALIZED_FILTER_EXEC_VARIANT)
                    plan_ptr_out, evaluations_ptr, output_length, output_chi_eval :=
                        generalized_filter_exec_evaluate(plan_ptr, builder_ptr)
                }
                default { err(ERR_UNSUPPORTED_PROOF_PLAN_VARIANT) }
            }

            let __planOutOffset
            __planOutOffset, __evaluations, __outputLength, __outputChiEvaluation :=
                proof_plan_evaluate(__plan.offset, __builder)
            __planOut.offset := __planOutOffset
            // slither-disable-next-line write-after-write
            __planOut.length := sub(__plan.length, sub(__planOutOffset, __plan.offset))
        }
        __builderOut = __builder;
    }
}
