// SPDX-License-Identifier: UNLICENSED
// This is licensed under the Cryptographic Open Software License 1.0
pragma solidity ^0.8.28;

import "../base/Constants.sol";
import "../base/Errors.sol";
import {VerificationBuilder} from "../builder/VerificationBuilder.presl";

/// @title GroupByExec
/// @dev Library for handling group by execution plans
library GroupByExec {
    /// @notice Evaluates a group by execution plan
    /// @custom:as-yul-wrapper
    /// #### Wrapped Yul Function
    /// ##### Signature
    /// ```yul
    /// group_by_exec_evaluate(plan_ptr, builder_ptr) -> plan_ptr_out, evaluations_ptr
    /// ```
    /// ##### Parameters
    /// * `plan_ptr` - calldata pointer to the group by execution plan
    /// * `builder_ptr` - memory pointer to the verification builder
    /// ##### Return Values
    /// * `plan_ptr_out` - pointer to the remaining plan after consuming the group by execution plan
    /// * `evaluations_ptr` - pointer to the evaluations
    /// * `output_length` - the length of the column of ones
    /// * `output_chi_eval` - pointer to the evaluation of a column of 1s with same length as output
    /// @notice Evaluates expressions for group by operation and verifies the aggregation constraints
    /// @notice ##### Constraints
    /// * Inputs: \\(G_1,\ldots,G_\ell=\texttt{g_in}\\), \\(A_1,\ldots,A_m=\texttt{sum_in}\\),
    ///   and \\(S=\texttt{sel_in}\\) with input characteristic \\(\chi_{[0,n)}=\texttt{input_chi_eval}\\).
    /// * Outputs: \\(G_1',\ldots,G_\ell'=\texttt{g_out}\\), \\(A_1',\ldots,A_m'=\texttt{sum_out}\\),
    ///   and \\(C=\texttt{count_out}\\) with output characteristic \\(\chi_{[0,m')}=\texttt{output_chi_eval}\\).
    /// * Challenges: \\(\alpha=\texttt{alpha}\\), \\(\beta=\texttt{beta}\\)
    /// * Helpers:
    ///   \\(g_{in,fold} \=\texttt{g_in_fold} :\equiv \alpha \sum_{j=1}^{\ell} G_j \beta^{\ell-j}\\)
    ///   \\(g_{out,fold} \=\texttt{g_out_fold} :\equiv \alpha \sum_{j=1}^{\ell} G_j' \beta^{\ell-j}\\)
    ///   \\(sum_{in,fold} \=\texttt{sum_in_fold} :\equiv \chi_{[0,n)} + \beta \sum_{j=1}^{m} A_j \beta^{m-j}\\)
    ///   \\(sum_{out,fold} \=\texttt{sum_out_fold} :\equiv C + \beta \sum_{j=1}^{m} A_j' \beta^{m-j}\\)
    ///   \\(G^\star = \texttt{g_in_star}\\) and \\(G^{\star'} = \texttt{g_out_star}\\)
    /// * Constraints:
    /// \\[\begin{aligned}
    /// G^\star \cdot S \cdot sum_{in,fold} - G^{\star'} \cdot sum_{out,fold} &\overset{\sum}{=} 0\\\\
    /// G^\star + G^\star \cdot g_{in,fold} - \chi_{[0,n)} &\equiv 0\\\\
    /// G^{\star'} + G^{\star'} \cdot g_{out,fold} - \chi_{[0,m')} &\equiv 0\\\\
    /// \end{aligned}\\]
    /// Note: the notation \\(A\overset{\sum}{=}B\\) is used to indicate the zero-sum constraint.
    /// @dev Evaluates a group by execution plan
    /// @param __plan The group by execution plan data
    /// @param __builder The verification builder
    /// @return __planOut The remaining plan after processing
    /// @return __builderOut The verification builder result
    /// @return __evaluationsPtr The evaluations pointer
    /// @return __outputLength The length of the output chi evaluation
    /// @return __outputChiEvaluation The output chi evaluation
    function __groupByExecEvaluate( // solhint-disable-line gas-calldata-parameters
    bytes calldata __plan, VerificationBuilder.Builder memory __builder)
        external
        pure
        returns (
            bytes calldata __planOut,
            VerificationBuilder.Builder memory __builderOut,
            uint256[] memory __evaluationsPtr,
            uint256 __outputLength,
            uint256 __outputChiEvaluation
        )
    {
        uint256[] memory __evaluations;
        assembly {
            // import err from ../base/Errors.sol
            // import addmod_bn254, mulmod_bn254, submod_bn254 from ../base/MathUtil.presl
            // import read_binary from ../base/DataType.presl
            // import builder_consume_challenge, builder_consume_chi_evaluation_with_length, builder_consume_first_round_mle, builder_get_table_chi_evaluation, builder_produce_zerosum_constraint from ../builder/VerificationBuilder.presl
            // import proof_expr_evaluate from ../proof_exprs/ProofExpr.presl
            // import fold_expr_evals from ../proof_gadgets/FoldUtil.presl
            // import fold_log_star_evaluate_from_column_exprs, fold_log_star_evaluate_from_mles from ../proof_gadgets/FoldLogExpr.presl
            // import monotonic_verify from ../proof_gadgets/Monotonic.presl

            function compute_g_in_star_eval(plan_ptr, builder_ptr, alpha, beta, input_chi_eval) ->
                plan_ptr_out,
                g_in_star_eval_times_selection_eval
            {
                let num_group_by_columns := shr(UINT64_PADDING_BITS, calldataload(plan_ptr))
                // We can not prove uniqueness for multiple columns yet
                if sub(num_group_by_columns, 1) { err(ERR_UNPROVABLE_GROUP_BY) }
                plan_ptr := add(plan_ptr, UINT64_SIZE)

                // Process group by columns
                let g_in_star_eval
                plan_ptr, g_in_star_eval :=
                    fold_log_star_evaluate_from_column_exprs(
                        plan_ptr, builder_ptr, alpha, beta, num_group_by_columns, input_chi_eval
                    )

                let selection_eval
                plan_ptr, selection_eval := proof_expr_evaluate(plan_ptr, builder_ptr, input_chi_eval)
                g_in_star_eval_times_selection_eval := mulmod_bn254(g_in_star_eval, selection_eval)
                plan_ptr_out := plan_ptr
            }

            function compute_sum_in_fold_eval(plan_ptr, builder_ptr, alpha, beta, input_chi_eval) ->
                plan_ptr_out,
                sum_in_fold_eval,
                num_sum_columns
            {
                num_sum_columns := shr(UINT64_PADDING_BITS, calldataload(plan_ptr))
                plan_ptr := add(plan_ptr, UINT64_SIZE)
                plan_ptr, sum_in_fold_eval :=
                    fold_expr_evals(plan_ptr, builder_ptr, input_chi_eval, beta, num_sum_columns)
                sum_in_fold_eval := addmod_bn254(mulmod_bn254(sum_in_fold_eval, beta), input_chi_eval)
                plan_ptr_out := plan_ptr
            }
            function compute_g_out_star_eval(builder_ptr, alpha, beta, output_chi_eval, evaluations_ptr) ->
                g_out_star_eval
            {
                let mles
                g_out_star_eval, mles := fold_log_star_evaluate_from_mles(builder_ptr, alpha, beta, 1, output_chi_eval)
                let mle := mload(add(mles, WORD_SIZE))
                mstore(evaluations_ptr, mle)
                evaluations_ptr := add(evaluations_ptr, WORD_SIZE)
                monotonic_verify(builder_ptr, alpha, beta, mle, output_chi_eval, 1, 1)
            }
            function compute_sum_out_fold_eval(
                builder_ptr, alpha, beta, output_chi_eval, num_sum_columns, evaluations_ptr
            ) -> sum_out_fold_eval {
                sum_out_fold_eval := 0
                for {} num_sum_columns { num_sum_columns := sub(num_sum_columns, 1) } {
                    // We increment evaluations_ptr first to avoid an unneceesary addition,
                    // Which means the value we pass in for evaluations_ptr should be adjusted accordingly
                    evaluations_ptr := add(evaluations_ptr, WORD_SIZE)
                    let mle := builder_consume_first_round_mle(builder_ptr)
                    sum_out_fold_eval := addmod_bn254(mulmod_bn254(sum_out_fold_eval, beta), mle)
                    mstore(evaluations_ptr, mle)
                }
            }

            function read_input_evals(plan_ptr, builder_ptr, alpha, beta) ->
                plan_ptr_out,
                partial_dlog_zero_sum_constraint_eval,
                num_sum_columns
            {
                // Read input chi evaluation
                let input_chi_eval
                {
                    let table_num := shr(UINT64_PADDING_BITS, calldataload(plan_ptr))
                    input_chi_eval := builder_get_table_chi_evaluation(builder_ptr, table_num)
                    plan_ptr := add(plan_ptr, UINT64_SIZE)
                }

                // Read/eval group by inputs, selection inputs, and fold and dlog them
                let g_in_star_eval_times_selection_eval
                plan_ptr, g_in_star_eval_times_selection_eval :=
                    compute_g_in_star_eval(plan_ptr, builder_ptr, alpha, beta, input_chi_eval)

                // Read/eval sum inputs and fold them
                let sum_in_fold_eval
                plan_ptr, sum_in_fold_eval, num_sum_columns :=
                    compute_sum_in_fold_eval(plan_ptr, builder_ptr, alpha, beta, input_chi_eval)

                partial_dlog_zero_sum_constraint_eval :=
                    mulmod_bn254(g_in_star_eval_times_selection_eval, sum_in_fold_eval)

                // Read count alias
                {
                    let count_alias
                    plan_ptr, count_alias := read_binary(plan_ptr)
                }

                plan_ptr_out := plan_ptr
            }

            function read_output_evals(
                builder_ptr, alpha, beta, partial_dlog_zero_sum_constraint_eval, num_group_by_columns, num_sum_columns
            ) -> evaluations_ptr, output_length, output_chi_eval {
                num_sum_columns := add(num_sum_columns, 1)
                // Allocate memory for evaluations
                {
                    let free_ptr := mload(FREE_PTR)
                    evaluations_ptr := free_ptr
                    let num_evals := add(num_group_by_columns, num_sum_columns)
                    mstore(free_ptr, num_evals)
                    free_ptr := add(free_ptr, WORD_SIZE)
                    free_ptr := add(free_ptr, mul(num_evals, WORD_SIZE))
                    mstore(FREE_PTR, free_ptr)
                }

                output_length, output_chi_eval := builder_consume_chi_evaluation_with_length(builder_ptr)

                let g_out_star_eval :=
                    compute_g_out_star_eval(builder_ptr, alpha, beta, output_chi_eval, add(evaluations_ptr, WORD_SIZE))

                let sum_out_fold_eval :=
                    compute_sum_out_fold_eval(
                        builder_ptr,
                        alpha,
                        beta,
                        output_chi_eval,
                        num_sum_columns,
                        add(evaluations_ptr, mul(num_group_by_columns, WORD_SIZE))
                    )

                builder_produce_zerosum_constraint(
                    builder_ptr,
                    submod_bn254(
                        partial_dlog_zero_sum_constraint_eval, mulmod_bn254(g_out_star_eval, sum_out_fold_eval)
                    ),
                    3
                )
            }

            function group_by_exec_evaluate(plan_ptr, builder_ptr) ->
                plan_ptr_out,
                evaluations_ptr,
                output_length,
                output_chi_eval
            {
                let alpha := builder_consume_challenge(builder_ptr)
                let beta := builder_consume_challenge(builder_ptr)

                let partial_dlog_zero_sum_constraint_eval, num_sum_columns
                plan_ptr_out, partial_dlog_zero_sum_constraint_eval, num_sum_columns :=
                    read_input_evals(plan_ptr, builder_ptr, alpha, beta)

                // Read output
                // For now, we can assume the number of group by columns is 1,
                // because the function would have errored by this point otherwise
                evaluations_ptr, output_length, output_chi_eval :=
                    read_output_evals(builder_ptr, alpha, beta, partial_dlog_zero_sum_constraint_eval, 1, num_sum_columns)
            }

            let __planOutOffset
            __planOutOffset, __evaluations, __outputLength, __outputChiEvaluation :=
                group_by_exec_evaluate(__plan.offset, __builder)
            __planOut.offset := __planOutOffset
            // slither-disable-next-line write-after-write
            __planOut.length := sub(__plan.length, sub(__planOutOffset, __plan.offset))
        }
        __evaluationsPtr = __evaluations;
        __builderOut = __builder;
    }
}
