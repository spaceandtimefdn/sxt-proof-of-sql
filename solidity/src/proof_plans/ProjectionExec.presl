// SPDX-License-Identifier: UNLICENSED
// This is licensed under the Cryptographic Open Software License 1.0
pragma solidity ^0.8.28;

import "../base/Constants.sol";
import "../base/Errors.sol";
import {VerificationBuilder} from "../builder/VerificationBuilder.presl";

/// @title ProjectionExec
/// @dev Library for handling projection execution plans
library ProjectionExec {
    /// @notice Evaluates a projection execution plan
    /// @custom:as-yul-wrapper
    /// #### Wrapped Yul Function
    /// ##### Signature
    /// ```yul
    /// projection_exec_evaluate(plan_ptr, builder_ptr) -> plan_ptr_out, evaluations_ptr, output_chi_eval
    /// ```
    /// ##### Parameters
    /// * `plan_ptr` - calldata pointer to the projection execution plan
    /// * `builder_ptr` - memory pointer to the verification builder
    /// ##### Return Values
    /// * `plan_ptr_out` - pointer to the remaining plan after consuming the projection execution plan
    /// * `evaluations_ptr` - pointer to the evaluations
    /// * `output_length` - the length of the column of ones
    /// * `output_chi_eval` - pointer to the evaluation of a column of 1s with same length as output
    /// * Outputs: \\(D_1,\ldots,D_\ell=\texttt{d}\\) with length \\(m\\), and thus \\(\chi_{[0,m)}=\texttt{output_chi_eval}\\).
    /// * Hints: No hints
    /// * Challenges: No challenges
    /// * Helpers: No helpers
    /// * Constraints: No constraints
    /// @notice ##### Proof of Correctness:
    /// TODO
    /// @notice **Completeness Proof:**
    /// TODO
    /// @notice **Soundness Proof:**
    /// TODO
    /// ##### Proof Plan Encoding
    /// The projection plan is encoded as follows:
    /// 1. the input proof plan
    /// 2. The number of input/output columns (64 bit integer)
    /// 3. The input column expressions, in order
    /// @dev Evaluates a projection execution plan
    /// @param __plan The projection execution plan data
    /// @param __builder The verification builder
    /// @return __planOut The remaining plan after processing
    /// @return __builderOut The verification builder result
    /// @return __evaluationsPtr The evaluations pointer
    /// @return __outputLength The length of the output chi evaluation
    /// @return __outputChiEvaluation The output chi evaluation
    function __projectionExecEvaluate( // solhint-disable-line gas-calldata-parameters
    bytes calldata __plan, VerificationBuilder.Builder memory __builder)
        external
        pure
        returns (
            bytes calldata __planOut,
            VerificationBuilder.Builder memory __builderOut,
            uint256[] memory __evaluationsPtr,
            uint256 __outputLength,
            uint256 __outputChiEvaluation
        )
    {
        uint256[] memory __evaluations;
        assembly {
            // import builder_get_column_evaluations, builder_set_column_evaluations from ../builder/VerificationBuilder.presl
            // import proof_expr_evaluate from ../proof_exprs/ProofExpr.presl
            // import proof_plan_evaluate from ../proof_plans/ProofPlan.presl

            function projection_exec_evaluate(plan_ptr, builder_ptr) -> plan_ptr_out, evaluations_ptr, output_length, output_chi_eval {
                let input_evaluations_ptr
                plan_ptr, input_evaluations_ptr, output_length, output_chi_eval :=
                    proof_plan_evaluate(plan_ptr, builder_ptr)

                let save_builder_evaluations := builder_get_column_evaluations(builder_ptr)
                builder_set_column_evaluations(builder_ptr, input_evaluations_ptr)

                let column_count := shr(UINT64_PADDING_BITS, calldataload(plan_ptr))
                plan_ptr := add(plan_ptr, UINT64_SIZE)

                evaluations_ptr := mload(FREE_PTR)
                mstore(FREE_PTR, add(evaluations_ptr, add(WORD_SIZE, mul(column_count, WORD_SIZE))))
                let target_ptr := evaluations_ptr
                mstore(target_ptr, column_count)

                for {} column_count { column_count := sub(column_count, 1) } {
                    target_ptr := add(target_ptr, WORD_SIZE)
                    let evaluation
                    plan_ptr, evaluation := proof_expr_evaluate(plan_ptr, builder_ptr, output_chi_eval, builder_get_column_evaluations(builder_ptr))

                    mstore(target_ptr, evaluation)
                }
                builder_set_column_evaluations(builder_ptr, save_builder_evaluations)

                plan_ptr_out := plan_ptr
            }

            let __planOutOffset
            __planOutOffset, __evaluations, __outputLength, __outputChiEvaluation :=
                projection_exec_evaluate(__plan.offset, __builder)
            __planOut.offset := __planOutOffset
            // slither-disable-next-line write-after-write
            __planOut.length := sub(__plan.length, sub(__planOutOffset, __plan.offset))
        }
        __evaluationsPtr = __evaluations;
        __builderOut = __builder;
    }
}
