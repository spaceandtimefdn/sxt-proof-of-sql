// SPDX-License-Identifier: UNLICENSED
// This is licensed under the Cryptographic Open Software License 1.0
pragma solidity ^0.8.28;

import "../base/Constants.sol";
import "../base/Errors.sol";

/// @title Result Verifier Library
/// @notice A library for verifying result evaluations.
library ResultVerifier {
    /// @notice Verifies that the evaluations of a column match with the provided evaluations.
    /// @notice Let \\(C\\) be a column of data, and let \\(E\\) be the evaluation vector.
    /// @notice The result evaluation is \\(\sum C[i] \cdot E[i]\\).
    /// @notice This is a wrapper around the `verify_result_evaluations` Yul function.
    /// @dev The format of the result is as follows:
    /// @dev * number of columns (64 bit unsigned integer)
    /// @dev * the following for each column:
    /// @dev   * column name length (64 bit unsigned integer)
    /// @dev   * column name (variable length - number of bytes specified by the column name length)
    /// @dev   * optional "quote" - must be 0 in the current implementation (single bytes)
    /// @dev   * column variant (32 bit unsigned integer)
    /// @dev       * Only supports the BigInt variant in the current implementation (0)
    /// @dev   * column length (64 bit unsigned integer)
    /// @dev   * column data (variable length
    /// @dev       * number of rows specified by the column length
    /// @dev       * each row is the data type specified by the column variant
    /// @dev           * BigInt - 64 bit signed integer (8 bytes)
    /// @param __result The result data: the columns.
    /// @param __evaluationPoint The evaluation point.
    /// @param __evaluations The evaluations to check against.
    function __verifyResultEvaluations(
        bytes calldata __result,
        uint256[] memory __evaluationPoint,
        uint256[] memory __evaluations
    ) external pure {
        assembly {
            // import err from ../base/Errors.sol
            // import addmod_bn254, mulmod_bn254 from ../base/MathUtil.presl
            // import read_data_type, read_entry from ../base/DataType.presl
            // import compute_evaluation_vec from ../base/LagrangeBasisEvaluation.presl

            function verify_result_evaluations(result_ptr, evaluation_point_ptr, evaluations_ptr) {
                let num_columns := shr(UINT64_PADDING_BITS, calldataload(result_ptr))
                result_ptr := add(result_ptr, UINT64_SIZE)
                if sub(num_columns, mload(evaluations_ptr)) { err(ERR_RESULT_COLUMN_COUNT_MISMATCH) }
                evaluations_ptr := add(evaluations_ptr, WORD_SIZE)

                let first := 1
                let table_len
                let eval_vec
                for {} num_columns { num_columns := sub(num_columns, 1) } {
                    let name_length := shr(UINT64_PADDING_BITS, calldataload(result_ptr))
                    result_ptr := add(result_ptr, add(UINT64_SIZE, name_length))
                    if byte(0, calldataload(result_ptr)) { err(ERR_INVALID_RESULT_COLUMN_NAME) }
                    result_ptr := add(result_ptr, 1)

                    let value := mload(evaluations_ptr)
                    evaluations_ptr := add(evaluations_ptr, WORD_SIZE)

                    let data_type_variant
                    result_ptr, data_type_variant := read_data_type(result_ptr)
                    let column_length := shr(UINT64_PADDING_BITS, calldataload(result_ptr))
                    result_ptr := add(result_ptr, UINT64_SIZE)

                    if first {
                        first := 0
                        table_len := column_length
                        eval_vec := compute_evaluation_vec(table_len, evaluation_point_ptr)
                    }
                    if sub(table_len, column_length) { err(ERR_INCONSISTENT_RESULT_COLUMN_LENGTHS) }

                    value := mulmod(MODULUS_MINUS_ONE, value, MODULUS)
                    let temp_eval_vec := eval_vec
                    for { let i := table_len } i { i := sub(i, 1) } {
                        let entry
                        result_ptr, entry := read_entry(result_ptr, data_type_variant)
                        value := addmod_bn254(value, mulmod_bn254(entry, mload(temp_eval_vec)))
                        temp_eval_vec := add(temp_eval_vec, WORD_SIZE)
                    }
                    if value { err(ERR_INCORRECT_RESULT) }
                }
            }
            verify_result_evaluations(__result.offset, __evaluationPoint, __evaluations)
        }
    }
}
